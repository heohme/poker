# å¾·å·æ‰‘å…‹å·¥å…·æŠ€æœ¯æ¶æ„æ–‡æ¡£

## 1. Architecture design

```mermaid
graph TD
  A[ç”¨æˆ·æµè§ˆå™¨] --> B[Reactå‰ç«¯åº”ç”¨]
  B --> C[Supabase SDK]
  C --> D[SupabaseæœåŠ¡]
  B --> E[WebSocketè¿æ¥]
  E --> F[å®æ—¶æ¸¸æˆæœåŠ¡]

  subgraph "å‰ç«¯å±‚"
    B
  end

  subgraph "å®æ—¶é€šä¿¡å±‚"
    E
    F
  end

  subgraph "åç«¯æœåŠ¡å±‚ (Supabaseæä¾›)"
    D
  end
```

## 2. Technology Description

* å‰ç«¯: React\@18 + TypeScript + Tailwind CSS + Vite

* åç«¯: Supabase (PostgreSQL + å®æ—¶è®¢é˜…)

* å®æ—¶é€šä¿¡: Supabase Realtime (WebSocket)

* çŠ¶æ€ç®¡ç†: React Context + useReducer (ç”¨æˆ·è§’è‰²çŠ¶æ€ç®¡ç†)

### 2.1 Mockè§’è‰²ç³»ç»ŸæŠ€æœ¯å®ç°

#### ç”¨æˆ·Contextè®¾è®¡

```typescript
// ç”¨æˆ·è§’è‰²æ•°æ®ç±»å‹
interface MockUser {
  id: string;
  name: string;
  avatar: string;
  initialChips: number;
  personality: string;
  currentChips: number;
  currentRoom?: string;
}

// ç”¨æˆ·Context
interface UserContextType {
  currentUser: MockUser | null;
  setCurrentUser: (user: MockUser) => void;
  updateUserChips: (chips: number) => void;
  joinRoom: (roomId: string) => void;
  leaveRoom: () => void;
}

// é¢„è®¾è§’è‰²æ•°æ®
const MOCK_USERS: Record<string, MockUser> = {
  bob: { id: 'bob', name: 'Bob', avatar: 'ğŸ§‘â€ğŸ’¼', initialChips: 1000, personality: 'ç¨³é‡å‹', currentChips: 1000 },
  alice: { id: 'alice', name: 'Alice', avatar: 'ğŸ‘©â€ğŸ’»', initialChips: 1200, personality: 'æ¿€è¿›å‹', currentChips: 1200 },
  charlie: { id: 'charlie', name: 'Charlie', avatar: 'ğŸ‘¨â€ğŸ¨', initialChips: 800, personality: 'æ–°æ‰‹å‹', currentChips: 800 },
  david: { id: 'david', name: 'David', avatar: 'ğŸ‘¨â€ğŸ”¬', initialChips: 1500, personality: 'ä¸“ä¸šå‹', currentChips: 1500 },
  eva: { id: 'eva', name: 'Eva', avatar: 'ğŸ‘©â€ğŸš€', initialChips: 1000, personality: 'éšæœºå‹', currentChips: 1000 },
  frank: { id: 'frank', name: 'Frank', avatar: 'ğŸ‘¨â€ğŸ³', initialChips: 900, personality: 'è°¨æ…å‹', currentChips: 900 }
};
```

#### URLå‚æ•°åŒæ­¥Hook

```typescript
// è‡ªå®šä¹‰Hookï¼šåŒæ­¥URLå‚æ•°å’Œç”¨æˆ·çŠ¶æ€
function useUserFromURL() {
  const [searchParams, setSearchParams] = useSearchParams();
  const { currentUser, setCurrentUser } = useContext(UserContext);
  
  useEffect(() => {
    const userParam = searchParams.get('user');
    if (userParam && MOCK_USERS[userParam] && currentUser?.id !== userParam) {
      setCurrentUser(MOCK_USERS[userParam]);
    }
  }, [searchParams, currentUser, setCurrentUser]);
  
  const updateUserParam = (userId: string) => {
    setSearchParams(prev => {
      prev.set('user', userId);
      return prev;
    });
  };
  
  return { updateUserParam };
}
```

### 2.2 æ¸¸æˆæ“ä½œç³»ç»ŸæŠ€æœ¯å®ç°

#### æ¸¸æˆçŠ¶æ€ç®¡ç†

```typescript
// æ¸¸æˆçŠ¶æ€æ•°æ®ç»“æ„
interface GameState {
  phase: 'preflop' | 'flop' | 'turn' | 'river' | 'showdown';
  currentPlayer: string;
  pot: number;
  currentBet: number;
  minRaise: number;
  players: PlayerState[];
  communityCards: Card[];
  bettingRound: number;
  isRoundComplete: boolean;
}

interface PlayerState {
  id: string;
  chips: number;
  currentBet: number;
  status: 'active' | 'folded' | 'allin' | 'disconnected';
  hasActed: boolean;
  lastAction: 'check' | 'call' | 'raise' | 'fold' | 'allin' | null;
}

// æ¸¸æˆæ“ä½œç±»å‹
type GameAction = {
  type: 'PLAYER_ACTION';
  payload: {
    playerId: string;
    action: 'check' | 'call' | 'raise' | 'fold' | 'allin';
    amount?: number;
  };
} | {
  type: 'NEXT_PHASE';
} | {
  type: 'RESET_ROUND';
};

// æ¸¸æˆçŠ¶æ€Reducer
function gameReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'PLAYER_ACTION':
      return handlePlayerAction(state, action.payload);
    case 'NEXT_PHASE':
      return advanceGamePhase(state);
    case 'RESET_ROUND':
      return resetBettingRound(state);
    default:
      return state;
  }
}
```

#### æ“ä½œéªŒè¯é€»è¾‘

```typescript
// æ“ä½œéªŒè¯å‡½æ•°
function validatePlayerAction(
  gameState: GameState,
  playerId: string,
  action: string,
  amount?: number
): { valid: boolean; error?: string } {
  const player = gameState.players.find(p => p.id === playerId);
  
  if (!player) {
    return { valid: false, error: 'ç©å®¶ä¸å­˜åœ¨' };
  }
  
  if (gameState.currentPlayer !== playerId) {
    return { valid: false, error: 'ä¸æ˜¯è¯¥ç©å®¶çš„å›åˆ' };
  }
  
  if (player.status !== 'active') {
    return { valid: false, error: 'ç©å®¶çŠ¶æ€ä¸å…è®¸æ“ä½œ' };
  }
  
  switch (action) {
    case 'check':
      if (gameState.currentBet > player.currentBet) {
        return { valid: false, error: 'æœ‰ä¸‹æ³¨æ—¶ä¸èƒ½è¿‡ç‰Œ' };
      }
      break;
      
    case 'call':
      const callAmount = gameState.currentBet - player.currentBet;
      if (callAmount <= 0) {
        return { valid: false, error: 'æ— éœ€è·Ÿæ³¨' };
      }
      if (player.chips < callAmount) {
        return { valid: false, error: 'ç­¹ç ä¸è¶³' };
      }
      break;
      
    case 'raise':
      if (!amount || amount < gameState.minRaise) {
        return { valid: false, error: 'åŠ æ³¨é‡‘é¢ä¸è¶³' };
      }
      if (player.chips < amount) {
        return { valid: false, error: 'ç­¹ç ä¸è¶³' };
      }
      break;
      
    case 'allin':
      if (player.chips <= 0) {
        return { valid: false, error: 'æ²¡æœ‰ç­¹ç å¯ä»¥å…¨æŠ¼' };
      }
      break;
      
    case 'fold':
      // å¼ƒç‰Œæ€»æ˜¯æœ‰æ•ˆçš„
      break;
      
    default:
      return { valid: false, error: 'æ— æ•ˆæ“ä½œ' };
  }
  
  return { valid: true };
}
```

#### å®æ—¶åŒæ­¥æœºåˆ¶

```typescript
// æ¸¸æˆçŠ¶æ€åŒæ­¥Hook
function useGameSync(roomId: string) {
  const [gameState, dispatch] = useReducer(gameReducer, initialGameState);
  const supabase = useSupabaseClient();
  
  useEffect(() => {
    // è®¢é˜…æ¸¸æˆçŠ¶æ€å˜åŒ–
    const subscription = supabase
      .channel(`game:${roomId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'games',
        filter: `room_id=eq.${roomId}`
      }, (payload) => {
        // æ›´æ–°æœ¬åœ°æ¸¸æˆçŠ¶æ€
        updateLocalGameState(payload.new);
      })
      .on('broadcast', { event: 'player_action' }, (payload) => {
        // å¤„ç†ç©å®¶æ“ä½œå¹¿æ’­
        dispatch({
          type: 'PLAYER_ACTION',
          payload: payload.payload
        });
      })
      .subscribe();
      
    return () => {
      subscription.unsubscribe();
    };
  }, [roomId, supabase]);
  
  // å‘é€ç©å®¶æ“ä½œ
  const sendPlayerAction = async (action: string, amount?: number) => {
    const validation = validatePlayerAction(gameState, currentUser.id, action, amount);
    
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    
    // å¹¿æ’­æ“ä½œåˆ°å…¶ä»–ç©å®¶
    await supabase.channel(`game:${roomId}`).send({
      type: 'broadcast',
      event: 'player_action',
      payload: {
        playerId: currentUser.id,
        action,
        amount
      }
    });
    
    // æ›´æ–°æ•°æ®åº“
    await supabase.from('game_actions').insert({
      game_id: gameState.id,
      player_id: currentUser.id,
      action_type: action,
      amount: amount || 0
    });
  };
  
  return { gameState, sendPlayerAction };
}
```

* è·¯ç”±: React Router\@6

## 3. Route definitions

| Route         | Purpose                 | URLå‚æ•°è¦æ±‚                        |
| ------------- | ----------------------- | ------------------------------ |
| /             | è§’è‰²é€‰æ‹©é¡µé¢ï¼Œç”¨æˆ·é€‰æ‹©mockè§’è‰²èº«ä»½     | æ— userå‚æ•°æ—¶æ˜¾ç¤ºï¼Œæœ‰æ•ˆuserå‚æ•°æ—¶é‡å®šå‘åˆ°/lobby |
| /lobby        | æˆ¿é—´å¤§å…é¡µé¢ï¼Œæ˜¾ç¤ºæˆ¿é—´åˆ—è¡¨å’Œåˆ›å»º/åŠ å…¥æˆ¿é—´åŠŸèƒ½ | å¿…é¡»åŒ…å«æœ‰æ•ˆçš„?user={è§’è‰²ID}å‚æ•°          |
| /room/create  | æˆ¿é—´è®¾ç½®é¡µé¢ï¼Œæˆ¿ä¸»é…ç½®æˆ¿é—´å‚æ•°         | å¿…é¡»åŒ…å«æœ‰æ•ˆçš„?user={è§’è‰²ID}å‚æ•°          |
| /room/:roomId | æ¸¸æˆé¡µé¢ï¼Œå¾·å·æ‰‘å…‹æ¸¸æˆä¸»ç•Œé¢          | å¿…é¡»åŒ…å«æœ‰æ•ˆçš„?user={è§’è‰²ID}å‚æ•°          |
| /game/result  | æ¸¸æˆç»“ç®—é¡µé¢ï¼Œæ˜¾ç¤ºå•å±€æ¸¸æˆç»“æœ         | å¿…é¡»åŒ…å«æœ‰æ•ˆçš„?user={è§’è‰²ID}å‚æ•°          |

### 3.1 è·¯ç”±å®ˆå«æœºåˆ¶

```typescript
// è·¯ç”±å®ˆå«ï¼šæ£€æŸ¥userå‚æ•°æœ‰æ•ˆæ€§
const VALID_USERS = ['bob', 'alice', 'charlie', 'david', 'eva', 'frank'];

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const [searchParams] = useSearchParams();
  const user = searchParams.get('user');
  
  if (!user || !VALID_USERS.includes(user)) {
    return <Navigate to="/" replace />;
  }
  
  return <>{children}</>;
}
```

## 4. API definitions

### 4.1 Core API

æˆ¿é—´ç®¡ç†ç›¸å…³

```
POST /api/rooms
```

Request:

| Param Name   | Param Type | isRequired | Description |
| ------------ | ---------- | ---------- | ----------- |
| name         | string     | true       | æˆ¿é—´åç§°        |
| smallBlind   | number     | true       | å°ç›²æ³¨é¢        |
| bigBlind     | number     | true       | å¤§ç›²æ³¨é¢        |
| initialChips | number     | true       | åˆå§‹ç­¹ç æ•°é‡      |
| maxPlayers   | number     | true       | æœ€å¤§ç©å®¶æ•°       |
| password     | string     | false      | æˆ¿é—´å¯†ç         |
| createdBy    | string     | true       | åˆ›å»ºè€…ç”¨æˆ·ID     |

Response:

| Param Name | Param Type | Description |
| ---------- | ---------- | ----------- |
| id         | string     | æˆ¿é—´å”¯ä¸€æ ‡è¯†      |
| status     | string     | æˆ¿é—´çŠ¶æ€        |
| players    | array      | å½“å‰ç©å®¶åˆ—è¡¨      |

Example:

```json
{
  "name": "Bobçš„æˆ¿é—´",
  "smallBlind": 10,
  "bigBlind": 20,
  "initialChips": 1000,
  "maxPlayers": 6,
  "password": "123456",
  "createdBy": "bob"
}
```

æ¸¸æˆæ“ä½œç›¸å…³

```
POST /api/game/action
```

Request:

| Param Name | Param Type | isRequired | Description                  |
| ---------- | ---------- | ---------- | ---------------------------- |
| roomId     | string     | true       | æˆ¿é—´ID                         |
| playerId   | string     | true       | ç©å®¶ID                         |
| action     | string     | true       | æ“ä½œç±»å‹ (fold/call/raise/allin) |
| amount     | number     | false      | ä¸‹æ³¨é‡‘é¢ (åŠ æ³¨æ—¶å¿…éœ€)                 |

Response:

| Param Name | Param Type | Description |
| ---------- | ---------- | ----------- |
| success    | boolean    | æ“ä½œæ˜¯å¦æˆåŠŸ      |
| gameState  | object     | æ›´æ–°åçš„æ¸¸æˆçŠ¶æ€    |

## 5. Server architecture diagram

```mermaid
graph TD
  A[å®¢æˆ·ç«¯/å‰ç«¯] --> B[Reactç»„ä»¶å±‚]
  B --> C[çŠ¶æ€ç®¡ç†å±‚]
  C --> D[Supabaseå®¢æˆ·ç«¯]
  D --> E[Supabaseæ•°æ®åº“]
  D --> F[Supabaseå®æ—¶è®¢é˜…]

  subgraph å‰ç«¯æ¶æ„
    B
    C
  end

  subgraph SupabaseæœåŠ¡
    E
    F
  end
```

## 6. Data model

### 6.1 Data model definition

```mermaid
erDiagram
  ROOMS ||--o{ PLAYERS : contains
  ROOMS ||--o{ GAMES : hosts
  GAMES ||--o{ GAME_ACTIONS : records
  PLAYERS ||--o{ GAME_ACTIONS : performs

  ROOMS {
    string id PK
    string name
    number small_blind
    number big_blind
    number initial_chips
    number max_players
    string password
    string status
    string created_by
    timestamp created_at
  }

  PLAYERS {
    string id PK
    string room_id FK
    string user_name
    number chips
    number position
    string status
    timestamp joined_at
  }

  GAMES {
    string id PK
    string room_id FK
    number round
    string phase
    json community_cards
    number pot
    number current_bet
    string current_player
    json game_state
    timestamp started_at
  }

  GAME_ACTIONS {
    string id PK
    string game_id FK
    string player_id FK
    string action_type
    number amount
    timestamp created_at
  }
```

### 6.2 Data Definition Language

æˆ¿é—´è¡¨ (rooms)

```sql
-- åˆ›å»ºæˆ¿é—´è¡¨
CREATE TABLE rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    small_blind INTEGER NOT NULL,
    big_blind INTEGER NOT NULL,
    initial_chips INTEGER NOT NULL,
    max_players INTEGER NOT NULL CHECK (max_players >= 2 AND max_players <= 10),
    password VARCHAR(50),
    status VARCHAR(20) DEFAULT 'waiting' CHECK (status IN ('waiting', 'playing', 'finished')),
    created_by VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_rooms_status ON rooms(status);
CREATE INDEX idx_rooms_created_by ON rooms(created_by);

-- æƒé™è®¾ç½®
GRANT SELECT ON rooms TO anon;
GRANT ALL PRIVILEGES ON rooms TO authenticated;
```

ç©å®¶è¡¨ (players)

```sql
-- åˆ›å»ºç©å®¶è¡¨
CREATE TABLE players (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID REFERENCES rooms(id) ON DELETE CASCADE,
    user_name VARCHAR(50) NOT NULL,
    chips INTEGER NOT NULL,
    position INTEGER NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'folded', 'allin', 'disconnected')),
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_players_room_id ON players(room_id);
CREATE INDEX idx_players_position ON players(room_id, position);

-- æƒé™è®¾ç½®
GRANT SELECT ON players TO anon;
GRANT ALL PRIVILEGES ON players TO authenticated;
```

æ¸¸æˆè¡¨ (games)

```sql
-- åˆ›å»ºæ¸¸æˆè¡¨
CREATE TABLE games (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID REFERENCES rooms(id) ON DELETE CASCADE,
    round INTEGER NOT NULL DEFAULT 1,
    phase VARCHAR(20) DEFAULT 'preflop' CHECK (phase IN ('preflop', 'flop', 'turn', 'river', 'showdown')),
    community_cards JSONB DEFAULT '[]',
    pot INTEGER DEFAULT 0,
    current_bet INTEGER DEFAULT 0,
    current_player UUID REFERENCES players(id),
    game_state JSONB DEFAULT '{}',
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_games_room_id ON games(room_id);
CREATE INDEX idx_games_phase ON games(phase);

-- æƒé™è®¾ç½®
GRANT SELECT ON games TO anon;
GRANT ALL PRIVILEGES ON games TO authenticated;
```

æ¸¸æˆæ“ä½œè¡¨ (game\_actions)

```sql
-- åˆ›å»ºæ¸¸æˆæ“ä½œè¡¨
CREATE TABLE game_actions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID REFERENCES games(id) ON DELETE CASCADE,
    player_id UUID REFERENCES players(id) ON DELETE CASCADE,
    action_type VARCHAR(20) NOT NULL CHECK (action_type IN ('fold', 'call', 'raise', 'check', 'allin')),
    amount INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_game_actions_game_id ON game_actions(game_id);
CREATE INDEX idx_game_actions_player_id ON game_actions(player_id);
CREATE INDEX idx_game_actions_created_at ON game_actions(created_at DESC);

-- æƒé™è®¾ç½®
GRANT SELECT ON game_actions TO anon;
GRANT ALL PRIVILEGES ON game_actions TO authenticated;
```

åˆå§‹åŒ–æ•°æ®

```sql
-- æ’å…¥mockè§’è‰²æ•°æ® (é€šè¿‡åº”ç”¨ç¨‹åºé€»è¾‘å¤„ç†ï¼Œä¸å­˜å‚¨åœ¨æ•°æ®åº“ä¸­)
-- Mockè§’è‰²: Bob, Alice, Charlie, David, Eva, Frank

-- ç¤ºä¾‹æˆ¿é—´æ•°æ®
INSERT INTO rooms (name, small_blind, big_blind, initial_chips, max_players, created_by)
VALUES 
('æ–°æ‰‹æˆ¿é—´', 5, 10, 1000, 6, 'bob'),
('é«˜çº§æˆ¿é—´', 25, 50, 5000, 8, 'alice');
```

